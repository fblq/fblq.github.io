
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>C/C++笔试 | 还是少年</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="zhong.zhou">
    
    <meta name="description" content="在一个源文件里定义了一个数组：char a[6];在另外一个文件里用下列语句进行了声明：extern char *a；请问，这样可以吗？

答案与分析：1）不可以，程序运行时会告诉你非法访问。原因在于，指向类型T的指针并不等价于类型T的数组。extern char a声明的是一个指针变量而不是字符数">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/author.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/author.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="还是少年" title="还是少年"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="还是少年">还是少年</a></h1>
				<h2 class="blog-motto">Think Different.</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">简介</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:github.com/fblq">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/03/15/C语言面试/" title="C/C++笔试" itemprop="url">C/C++笔试</a>
  </h1>
  <p class="article-author">By
    
      <a href="https://github.com/fblq" title="zhong.zhou">zhong.zhou</a>
    </p>
  <p class="article-time">
    <time datetime="2015-03-15T03:57:11.000Z" itemprop="datePublished">2015-03-15</time>
    更新日期:<time datetime="2018-07-29T04:34:31.000Z" itemprop="dateModified">2018-07-29</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
		</div>
		
		<blockquote>
<p>在一个源文件里定义了一个数组：char a[6];在另外一个文件里用下列语句进行了声明：extern char *a；<br>请问，这样可以吗？</p>
</blockquote>
<p>答案与分析：<br>1）不可以，程序运行时会告诉你非法访问。原因在于，指向类型T的指针并不等价于类型T的数组。extern char <em>a声明的是一个指针变量而不是字符数组，因此与实际的定义不同，从而造成运行时非法访问。应该将声明改为extern char a[ ]。<br>2）例子分析如下，如果a[] = “abcd”,则外部变量a=0x12345678 (数组的起始地址)，而\</em>a是重新定义了一个指针变量，a的地址可能是0x87654321,直接使用*a是错误的.<br>3）这提示我们，在使用extern时候要严格对应声明时的格式，在实际编程中，这样的错误屡见不鲜。<br>4）extern用在变量声明中常常有这样一个作用：你要在*.c文件中引用另一个文件中的一个全局的变量，那就应该放在*.h中用extern来声明这个全局变量。</p>
<blockquote>
<p>字符串的存储方式以及区别？</p>
</blockquote>
<p>1）用字符数组存储，char a[10];<br>2）用字符指针存储，char *a=”abcdef”;</p>
<blockquote>
<p>字符串中sizeof和strlen的区别？</p>
</blockquote>
<p>sizeof()和初始化没关系，strlen和初始化有关系</p>
<blockquote>
<p>C和C++中的struct的不同点？</p>
</blockquote>
<p>C中struct不可以有 成员函数，C++中的struct可以含有成员函数。<br>C++中的struct默认为public，而class默认为private</p>
<blockquote>
<p>int （<em>Fun[5]）(int ,int )和 int </em>Fun（int，int）</p>
</blockquote>
<p>函数指针和函数数组指针？</p>
<blockquote>
<p>void Fun(char str[100]){;} 和 void <em>p = malloc(100); char </em>q;</p>
</blockquote>
<p>求sizeof(str)、sizeof(p)和sizeof(q)   答案：4；4；4<br>指针存储的是变量的地址，不是变量本身，所以指针指向任何数据类型，它的大小就是一个地址的大小（4<em>8）。<br>(void\</em>)ptr 和 (*(void**))ptr 的值相同<br>对绝对地址0x100000赋值：(unsigned int<em>)0x100000=1234<br>让程序跳到绝对地址0x100000去执行：\</em>((void (*) ())ox100000)()</p>
<blockquote>
<p>bool add(int a,int b, int<em> c)<br>{
    </em>c=a+b;<br>    return (a&gt;0 &amp;&amp; b&gt;0 &amp;&amp; (<em>c&lt;a || </em>c<b) )||="" (a<0="" &&="" b<0="" (="" \*c="">a ||*c&gt;b)))<br>}</b)></p>
</blockquote>
<p>返回值为真则溢出；</p>
<blockquote>
<p>定义指针：char *p = null;  </p>
</blockquote>
<p>定义时初始化，防止出现野指针</p>
<blockquote>
<p>关于内存的思考：（值传递）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void GetMemory(char *p)</span><br><span class="line">&#123;</span><br><span class="line">	p=(char*) malloc(100); //malloc返回的是void型的内存地址</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	char *str=null;</span><br><span class="line">	GetMemory(str);</span><br><span class="line">	strcpy(str,&quot;hello world&quot;);</span><br><span class="line">	printf(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>程序分析：程序奔溃，函数GetMemory不能返回动态内存，str一直为null;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char *GetMemory(void)</span><br><span class="line">&#123;</span><br><span class="line">	char p[]=&quot;hello&quot;;</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	char *str=null;</span><br><span class="line">	str=GetMemory();</span><br><span class="line">	printf(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序分析：可能是乱码，GetMemory返回的是栈内存的指针，该指针的地址不是null，但其内容已经被清除，新内容未知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void GetMemory(char **p,int num)</span><br><span class="line">&#123;</span><br><span class="line">	*p= (char *)malloc(num);</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	char *str=null;</span><br><span class="line">	GetMomory(&amp;str,100);</span><br><span class="line">	strcpy(str,&quot;hello&quot;);</span><br><span class="line">	printf(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序分析：能输出hello，但造成内存泄露。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void Test(void)</span><br><span class="line">&#123;</span><br><span class="line">	char *str=(char *)malloc (100);</span><br><span class="line">	strcpy(str,&quot;hello&quot;);</span><br><span class="line">	free(str);   //释放了指针指向的内容，但并没有清理指针本身，此时str指向垃圾内存</span><br><span class="line">	if(str!=null)</span><br><span class="line">	&#123;</span><br><span class="line">		strcpy(str,&quot;world&quot;);</span><br><span class="line">		printf(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序分析：篡改动态内存区的内容，后果难以预料，非常危险。</p>
<blockquote>
<p>关键字volatile有什么含义？并给出具体的应用？</p>
</blockquote>
<p>一个定义为volatile的变量，编译器将不会对使用该变量的代码进行优化，目的为了提供特殊地址的稳定访问。也就是说程序在每次使用该变量时，都会从实际内存中读取最新的值而不是暂存的数据。<br>具体应用：<br>1）存储器映射的硬件寄存器；<br>2）中断服务程序中修改的供其他程序使用的变量；<br>3）多任务条件下任务间共享的标志。（编译器对象的值可能在编译器未监测的情况下发生改变）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;filename.h&gt; 和 #include &quot;filename.h&quot;的区别？</span><br></pre></td></tr></table></figure>
<p>对于前者，编译器从标准库路径开始搜索；对于后者，编译去从用户的工作路径开始搜索。<br>头文件中的ifndef/define/endif 的作用：防止头文件被重复利用。</p>
<blockquote>
<p>const、static的用途？</p>
</blockquote>
<p>const：定义常量；修饰函数<br>static：改变变量的存储方式；限制变量的作用域。</p>
<p>堆栈溢出一般缘由：没有回收垃圾资源。<br>引用已经定义的变量：头文件引用；使用extern进行引用。（编译与连接）<br>全局变量被定义在多个.C文件包含的头文件里，可用static形式来声明，但只能有一个C文件对此变量赋初值。</p>
<p>栈与堆的区别:<br>栈的空间由操作系统自动进行分配和释放，栈的空间有限；<br>堆的空间有程序员手动进行分配和释放，C中调用标准库函数malloc和free，C++中使用操作符new和delete；<br>程序在编译期间对变量和函数的内存分配在栈上进行，程序在运行时对函数调用时参数的传递也在栈上进行。</p>
<p>宏定义写swap(x,y): </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define swap(x,y) (x)=(x)^(y);(y)=(x)^(y);(x)=(x)^(y);</span><br><span class="line">#define swap(x,y) (x)=(x)+(y);(y)=(x)-(y);(x)=(x)-(y);</span><br><span class="line">#define Min(x,y) ((x)&gt;(y)?(y):(x))   //后面没有;</span><br><span class="line">#define NUM(table) (sizeof(table)/sizeof(table[0]))</span><br></pre></td></tr></table></figure>
<p>带参宏和带参函数的区别：<br>带参宏在编译时处理，无参数类型，变长，不占用存储空间，不占运行时间。<br>带参函数运行时处理，需要定义参数类型，程序长度不变，占用存储空间，调用和返回时占用运行时间。</p>
<p>main函数不会被其他函数调用，为什么要有返回值？<br>main中，C标准认为0表示成功，非零表示错误，具体的值是某种具体的出错信息。</p>
<p>C语言中内存分为哪五个区：静态存储区、栈区、堆区、字符串常量区、代码区</p>
<blockquote>
<p>动态存储区（栈区）：函数形参、函数内的局部变量<br>静态存储区：全局变量和静态变量<br>堆区：动态分配函数malloc分配的空间，需使用free释放<br>字符串常量区：不同的函数使用相同的字符串常量在内存中会共用。<br>代码区:程序的二进制代码</p>
</blockquote>
<p>static函数与普通函数的区别：static函数在内存中只存一份，普通函数在每次调用中维持一份拷贝。<br>什么是预编译？何时需要预编译？<br>预编译又称预处理，是做些代码文本的替换工作。（宏定义、文件包含、条件编译）<br>使用情况：<br>1)、总是使用不经常改动的大型代码体<br>2)、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。<br>用栈实现队列的功能？两个栈实现一个队列的功能。<br>一个频繁使用的短小函数，在C中用宏定义实现，在C++中用inline实现。<br>switch的参数类型不能为实型。<br>中断服务子程序（ISR）的特点：<br>无返回值；<br>不能传递参数；<br>短而且有效，不能做复杂的运算，RTOS；<br>printf经常有重入性和性能上的问题<br>（可重入函数：函数可以被多个任务并发使用而且不发生数据错误，即允许中断）<br>自动转换原则：就高不就低（char、short、int、unsigned、long、(float)double）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">整数自动转换原则</span><br><span class="line">void foo(void)</span><br><span class="line">&#123;</span><br><span class="line">	 unsigned int a= 6;</span><br><span class="line">	 int b=-20;</span><br><span class="line">	 (a+b&gt;6)？puts(&quot;&gt;6&quot;):puts(&quot;&lt;=6&quot;);</span><br><span class="line">&#125;</span><br><span class="line">结果：&gt;6   (int 自动转换为 unsigned int)</span><br></pre></td></tr></table></figure></p>
<p>评价下面的代码片段 (处理器字长的重要性)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int zero=0；</span><br><span class="line">unsigned int compzero=0xFFFF;  --&gt;unsigned int compzero=~0;</span><br></pre></td></tr></table></figure></p>
<p>链式表达式：int length=strlen(strcpy(strDest,”HelloWorld”));<br>&lt; !– 说明：strcpy的参数为指针，能实现strSrc的内容复制到strDest,但为什么要有char*类型的返回值 –&gt;<br>类的大小只与成员变量（非static数据成员变量）和虚函数指针有关，还要考虑到对齐. </p>
<p>如果 const 位于 <em> 的左侧，则 const 就是用来修饰指针所指向的变量，即指针指向为常量；<br>如果 const 位于 </em> 的右侧， const 就是修饰指针本身，即指针本身是常量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a=248, b=4;</span><br><span class="line">int const c=21;</span><br><span class="line">const int *d=&amp; a; </span><br><span class="line">int *const e=&amp; b;</span><br><span class="line">int const *f const =&amp; a;</span><br></pre></td></tr></table></figure></p>
<p>请问下列表达式哪些会被编译器禁止?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A *c=32</span><br><span class="line">B *d=43</span><br><span class="line">C e=&amp;a</span><br><span class="line">D f=0x321f</span><br><span class="line">E d=&amp;b</span><br><span class="line">F *e=34</span><br></pre></td></tr></table></figure></p>
<p>答案：A B C D</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *p1 = new int[10];  //没有进行初始化</span><br><span class="line">int *p2 = new int[10]();   //初始化为NULL</span><br></pre></td></tr></table></figure>
<p>函数模板必须由编译器根据程序员的调用类型实例化为可执行的函数<br>一个类定义中，只要有一个函数模板，则这个类是类模板<br>类模板的成员函数都是函数模板，类模板实例化后，成员函数也随之实例化</p>
<p>用户态切换到内核态的3种方式：</p>
<blockquote>
<p>a.  系统调用<br>b.  异常<br>c.  外围设备的中断 </p>
</blockquote>
<p>动态链接库和静态链接库的优缺点：</p>
<blockquote>
<p>动态链接库<br>优点：<br>1）减少内存，减少了内存页面的切换。<br>2）.DLL文件与.EXE文件相互独立，只要输出接口不变，.DLL文件发生改变也不会影响.EXE文件，因而提高了维护性和可扩展性。<br>3）不同的编程语言只要按照函数调用的约定就可以调用同一个DLL函数<br>4）适用于大规模的软件开发，开发过程独立，耦合度小，便于不同开发者和开发组织之间进行开发和测试。<br>缺点：使用程序不是自完动态链接库的备的，依赖于DLL模块存在；新模块和旧模块不兼容会造成与此模块相关联的模块全部不可用。<br>静态链接库<br>优点：<br>1）代码装载速度快，执行速率比动态链接稍快<br>2）只需要保证.LIB文件正确，发布时不需要考虑版本是否已经存在<br>缺点：使用静态链接库生成的可执行文件体积大，包含相同的公共代码，造成浪费。</p>
</blockquote>
<p>列出数据库中常用的锁及其应用场景</p>
<blockquote>
<p>排他锁：事物T给数据对象A加上X锁，事物T可以对A进行读取和修改，其他事物想给A加锁时必须等待T释放，保证在T释放锁之前不能对A进行读取和修改的操作。<br>共享锁：事物T对数据对象A加上S锁，可以对A进行读取，但不能修改，其他事物在T释放S锁之前不能对A加X锁，但可以加S锁，保证了在T进行读取操作时，其他事物可以进行读取，但不能进行修改操作。<br>死锁：事物T对数据对象A进行了封锁操作，事物F对数据对象B进行了封锁操作，而T和F又相互申请封锁对方已经封锁的数据，二者相互等待，一直不能结束。<br>活锁：事物T堆数据对象A进行了封锁操作，同时又新的事物来申请对A进行封锁操作，但一直响应最新的请求，导致排队的事物一直等待下去。</p>
</blockquote>
<p>轮询任务调度和可抢占式调度有什么区别？</p>
<blockquote>
<p>轮询调度是让进程运行直至结束或者阻塞的调度方式，实现简单，适用于专用的操作系统；<br>可抢占式调度可以在进程的执行的过程中依据优先级终止进程的执行的调度方式，防止单一进程一直占用CPU，控制系统的开销。</p>
</blockquote>
<p>在现代系统的设计过程中,为了减轻请求的压力,通常采用缓存技术。为了进一步提升缓存的命中率,通常采用分布式缓存方案。即前端的调度模块,将针对不同内容的用户请求分配不同的缓存服务器向用户提供服务。请给出一个分布式缓存方案,满足如下要求:<br>1)单台缓存服务器故障,整个分布式缓存集群,可以继续提供服务;<br>2)通过一定的分配策略,可以保证充分利用每个缓存服务的存储空间,及负载均衡。当部分服务器故障或系统扩容时,该分配策略可以保证较小的缓存文件重分配开销；<br>3)当不同缓存服务器的存储空间存在差异时,分配策略可以满足比例分配。</p>
<blockquote>
<p>1）采用环形的HASH数值空间，对象和cache服务器都使用相同的hash算法映射到hash数值空间，在对象和cache服务器的映射关系中，采用顺时针的查找的方式，将对象映射到顺时针方向上最接近的cache服务器上，如果单台cache服务器发生故障，对象则在顺时针方向上去找下一个cache服务器，重新建立映射关系。<br>2）在1）的基础上，当访问数量剧增时，新增cache服务器，将其映射到hash数值空间，只需要改变它逆时针方向上在下一个cache服务器之前的对象的映射关系；<br>  采用建立虚拟节点的策略，即为每一个实际存在的节点创建多个副本，通过hash算法映射到hash数值空间，增大的cache的虚拟数目，提高了cache服务器被映射的公平性，增大了其平衡性。<br>3）根据cache服务器的存储空间的大小来确定它的复制个数，存储空间大的适当增大其复制的个数，实现分配策略的公平性。</p>
</blockquote>
<p>大小端问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//数据存储</span><br><span class="line">//解释一下原码、补码、反码</span><br><span class="line">union Test</span><br><span class="line"> &#123;</span><br><span class="line">    char a[4];</span><br><span class="line">    short b;</span><br><span class="line"> &#125;;</span><br><span class="line"> Test test;</span><br><span class="line"> test.a[0]=256;</span><br><span class="line"> test.a[1]=255;</span><br><span class="line"> test.a[2]=254;</span><br><span class="line"> test.a[3]=253;</span><br><span class="line"> printf(&quot;%d\n&quot;,test.b);</span><br></pre></td></tr></table></figure></p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/C语言/">C语言</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/面试题/">面试题</a>
</div>



<div class="article-share" id="share">

  <div data-url="https://github.com/fblq/2015/03/15/C语言面试/" data-title="C/C++笔试 | 还是少年" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/03/25/epoll与select/" title="epoll与select">
  <strong>PREVIOUS:</strong><br/>
  <span>
  epoll与select</span>
</a>
</div>


<div class="next">
<a href="/2015/03/13/makefile文件的作用和写法/"  title="makefile文件的应用">
 <strong>NEXT:</strong><br/> 
 <span>makefile文件的应用
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Android应用/" title="Android应用">Android应用<sup>1</sup></a></li>
		
			<li><a href="/categories/web开发/" title="web开发">web开发<sup>3</sup></a></li>
		
			<li><a href="/categories/工程应用/" title="工程应用">工程应用<sup>1</sup></a></li>
		
			<li><a href="/categories/开发工具/" title="开发工具">开发工具<sup>2</sup></a></li>
		
			<li><a href="/categories/操作系统/" title="操作系统">操作系统<sup>1</sup></a></li>
		
			<li><a href="/categories/数据库/" title="数据库">数据库<sup>1</sup></a></li>
		
			<li><a href="/categories/数据结构与算法/" title="数据结构与算法">数据结构与算法<sup>5</sup></a></li>
		
			<li><a href="/categories/缓存应用/" title="缓存应用">缓存应用<sup>1</sup></a></li>
		
			<li><a href="/categories/网络基础/" title="网络基础">网络基础<sup>5</sup></a></li>
		
			<li><a href="/categories/设计模式/" title="设计模式">设计模式<sup>1</sup></a></li>
		
			<li><a href="/categories/面试题/" title="面试题">面试题<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
      <li><a href="http://hexo.io" target="_blank" title="Hexo">Hexo</a></li>
    </ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello, I&#39;m zhong.zhou. This is my blog on Gitbub. <br/>
			如果非要去地狱一趟，那就走吧！-丘吉尔</p>
	</section>
	 
	<div class="social-font clearfix">
		
		
		
		<a href="https://github.com/fblq" target="_blank" title="github"></a>
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2018 
		
		<a href="https://github.com/fblq" target="_blank" title="zhong.zhou">zhong.zhou</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"fblq"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 




<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;">
<a title="���ض���"><img src="/img/scrollup.png"/></a>
</div>
<script src="/js/totop.js"></script>

  </body>
</html>
