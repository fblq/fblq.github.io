
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Socket通信原理与实践 | 木心少年</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="zhong.zhou">
    
    <meta name="description" content="引言网络中进程之间如何通信，如我们每天打开浏览器浏览网页时，浏览器的进程怎么与web服务器通信的？当你用QQ聊天时，QQ进程怎么与服务器或你好友所在的QQ进程通信？这些都得靠socket？那什么是socket？socket的类型有哪些？还有socket的基本函数有哪些？

网络进程如何通信本地的进程">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/author.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/author.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="木心少年" title="木心少年"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="木心少年">木心少年</a></h1>
				<h2 class="blog-motto">如果非要去地狱，那就走一趟吧！-丘吉尔</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">简介</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/03/07/Socket通信模式与行为/" title="Socket通信原理与实践" itemprop="url">Socket通信原理与实践</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://yoursite.com" title="zhong.zhou">zhong.zhou</a>
    </p>
  <p class="article-time">
    <time datetime="2015-03-07T06:14:03.000Z" itemprop="datePublished">2015-03-07</time>
    更新日期:<time datetime="2018-07-28T13:16:15.000Z" itemprop="dateModified">2018-07-28</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#引言"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络进程如何通信"><span class="toc-number">2.</span> <span class="toc-text">网络进程如何通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是Socket"><span class="toc-number">3.</span> <span class="toc-text">什么是Socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socket的基本操作"><span class="toc-number">4.</span> <span class="toc-text">socket的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#socket-函数"><span class="toc-number">4.1.</span> <span class="toc-text">socket()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind-函数"><span class="toc-number">4.2.</span> <span class="toc-text">bind()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#listen-、connect-函数"><span class="toc-number">4.3.</span> <span class="toc-text">listen()、connect()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#accept-函数"><span class="toc-number">4.4.</span> <span class="toc-text">accept()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#read-、write-等函数"><span class="toc-number">4.5.</span> <span class="toc-text">read()、write()等函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#close-函数"><span class="toc-number">4.6.</span> <span class="toc-text">close()函数</span></a></li></ol></li></ol>
		</div>
		
		<hr>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>网络中进程之间如何通信，如我们每天打开浏览器浏览网页时，浏览器的进程怎么与web服务器通信的？当你用QQ聊天时，QQ进程怎么与服务器或你好友所在的QQ进程通信？这些都得靠socket？那什么是socket？socket的类型有哪些？还有socket的基本函数有哪些？</p>
<hr>
<h2 id="网络进程如何通信"><a href="#网络进程如何通信" class="headerlink" title="网络进程如何通信"></a>网络进程如何通信</h2><p>本地的进程间通信（IPC）有很多种方式，可以总结为：</p>
<blockquote>
<p>1）消息传递（管道、FIFO、消息队列）<br>2）同步（互斥量、条件变量、读写锁、文件读和记录锁、信号量）<br>3）共享内存（匿名的和具名的）<br>4）远程过程调用（Solaris门和Sun RPC）</p>
</blockquote>
<p>本文要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p>
<p>TCP/IP协议的应用程序通常采用应用编程接口：UNIX  BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），实现网络进程之间的通信。</p>
<blockquote>
<p>目前，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，可以说“一切皆socket”。</p>
</blockquote>
<hr>
<h2 id="什么是Socket"><a href="#什么是Socket" class="headerlink" title="什么是Socket"></a>什么是Socket</h2><p>socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。<br>Socket就是该模式的一个实现，socket即是一种特殊的文件，socket函数就是对其进行的操作（读写IO、打开、关闭），这些函数会在后面进行介绍。<br>Socket是tcp\ip网络协议接口。内部定义了许多的函数和例程。可以看成是网络通信的一个端点。在网络通信中需要两个主机或两个进程。通过网络传递数据，程序在网络对话的每一端需要一个socket。<br>tcp/ip传输层使用协议端口将数据传送给一个主机的特定应用程序，协议端口是一个应用程序的进程地址。传输层模块的网络软件模块要与另一个程序通信，它将使用协议端口，socket是运行在传输层的api，使用socket建立连接发送数据要指定一个端口给它。</p>
<hr>
<h2 id="socket的基本操作"><a href="#socket的基本操作" class="headerlink" title="socket的基本操作"></a>socket的基本操作</h2><p>既然socket是“open—write/read—close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。下面以TCP为例，介绍几个基本的socket接口函数。</p>
<hr>
<h3 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket()函数"></a>socket()函数</h3><p>int socket(int domain, int type, int protocol);<br>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。<br>正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p>
<ul>
<li>domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li>
<li>type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。</li>
<li>protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。<br><strong>注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</strong></li>
</ul>
<p>当我们调用socket创建一个socket时，返回的socket描述字存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。<br><strong>如果想要给它赋值一个地址，就必须调用bind()函数，否则当调用connect()、listen()时系统会自动随机分配一个端口。</strong></p>
<hr>
<h3 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind()函数"></a>bind()函数</h3><p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p>
<p>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<br>函数的三个参数分别为：</p>
<ul>
<li>sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。</li>
<li>addr：const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同。</li>
</ul>
<hr>
<h3 id="listen-、connect-函数"><a href="#listen-、connect-函数" class="headerlink" title="listen()、connect()函数"></a>listen()、connect()函数</h3><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p>
<p>  int listen(int sockfd, int backlog);<br>  int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p>
<p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。<strong>socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</strong></p>
<p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p>
<hr>
<h3 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept()函数"></a>accept()函数</h3><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就向TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p>
<p>int accept(int sockfd, struct sockaddr <em>addr, socklen_t </em>addrlen);<br>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p>
<p><strong>注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</strong></p>
<hr>
<h3 id="read-、write-等函数"><a href="#read-、write-等函数" class="headerlink" title="read()、write()等函数"></a>read()、write()等函数</h3><p>万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p>
<p>  read()/write()<br>  recv()/send()<br>  readv()/writev()<br>  recvmsg()/sendmsg()<br>  recvfrom()/sendto()</p>
<p>我推荐使用recvmsg()/sendmsg()函数，这两个函数是最通用的I/O函数，实际上可以把上面的其它函数都替换成这两个函数。它们的声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize\_t read(int fd, void *buf, size_t count);</span><br><span class="line">ssize\_t write(int fd, const void *buf, size_t count);</span><br><span class="line"></span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span><br><span class="line">ssize_t recv(int sockfd, void *buf, size_t len, int flags);</span><br><span class="line"></span><br><span class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,</span><br><span class="line">                    const struct sockaddr *dest_addr, socklen_t addrlen);</span><br><span class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</span><br><span class="line">                      struct sockaddr *src_addr, socklen_t *addrlen);</span><br><span class="line"></span><br><span class="line">ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</span><br><span class="line">ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</span><br></pre></td></tr></table></figure>
<p>read函数是负责从fd中读取内容。当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。</p>
<p>write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。<br>1)write的返回值大于0，表示写了部分或者是全部的数据。<br>2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。</p>
<p>其它的我就不一一介绍,这几对I/O函数了，具体参见man文档或者baidu、Google，下面的例子中将使用到send/recv。</p>
<hr>
<h3 id="close-函数"><a href="#close-函数" class="headerlink" title="close()函数"></a>close()函数</h3><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p>
<p>close一个TCP socket的缺省行为时把该socket标记为已关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p>
<p><strong>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</strong></p>
<p>Socket的相关应用：<a href="http://blog.csdn.net/u011608357/article/details/18862853/" target="_blank" rel="external">socket获取本机IP地址方法</a></p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/网络编程/">网络编程</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/网络基础/">网络基础</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://yoursite.com/2015/03/07/Socket通信模式与行为/" data-title="Socket通信原理与实践 | 木心少年" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/03/10/操作系统的基础知识/" title="操作系统基础概念">
  <strong>PREVIOUS:</strong><br/>
  <span>
  操作系统基础概念</span>
</a>
</div>


</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#引言"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络进程如何通信"><span class="toc-number">2.</span> <span class="toc-text">网络进程如何通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是Socket"><span class="toc-number">3.</span> <span class="toc-text">什么是Socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socket的基本操作"><span class="toc-number">4.</span> <span class="toc-text">socket的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#socket-函数"><span class="toc-number">4.1.</span> <span class="toc-text">socket()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind-函数"><span class="toc-number">4.2.</span> <span class="toc-text">bind()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#listen-、connect-函数"><span class="toc-number">4.3.</span> <span class="toc-text">listen()、connect()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#accept-函数"><span class="toc-number">4.4.</span> <span class="toc-text">accept()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#read-、write-等函数"><span class="toc-number">4.5.</span> <span class="toc-text">read()、write()等函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#close-函数"><span class="toc-number">4.6.</span> <span class="toc-text">close()函数</span></a></li></ol></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Android应用/" title="Android应用">Android应用<sup>1</sup></a></li>
		
			<li><a href="/categories/web开发/" title="web开发">web开发<sup>3</sup></a></li>
		
			<li><a href="/categories/工程应用/" title="工程应用">工程应用<sup>1</sup></a></li>
		
			<li><a href="/categories/开发工具/" title="开发工具">开发工具<sup>2</sup></a></li>
		
			<li><a href="/categories/操作系统/" title="操作系统">操作系统<sup>1</sup></a></li>
		
			<li><a href="/categories/数据库/" title="数据库">数据库<sup>1</sup></a></li>
		
			<li><a href="/categories/数据结构与算法/" title="数据结构与算法">数据结构与算法<sup>5</sup></a></li>
		
			<li><a href="/categories/缓存应用/" title="缓存应用">缓存应用<sup>1</sup></a></li>
		
			<li><a href="/categories/网络基础/" title="网络基础">网络基础<sup>5</sup></a></li>
		
			<li><a href="/categories/设计模式/" title="设计模式">设计模式<sup>1</sup></a></li>
		
			<li><a href="/categories/面试题/" title="面试题">面试题<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
      <li><a href="http://wsgzao.github.io/" target="_blank" title="wsgzao">wsgzao's blog</a></li>
      <li><a href="http://hexo.io" target="_blank" title="Hexo">Hexo</a></li>
    </ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello, I&#39;m zhong.zhou. This is my blog on Gitbub. <br/>
			no more no better</p>
	</section>
	 
	<div class="social-font clearfix">
		
		<a href="http://weibo.com/5607185050" target="_blank" title="weibo"></a>
		
		
		
		<a href="https://github.com/fblq" target="_blank" title="github"></a>
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2018 
		
		<a href="http://yoursite.com" target="_blank" title="zhong.zhou">zhong.zhou</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"fblq"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 




<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;">
<a title="���ض���"><img src="/img/scrollup.png"/></a>
</div>
<script src="/js/totop.js"></script>

  </body>
</html>
